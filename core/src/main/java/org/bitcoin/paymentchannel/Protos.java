// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentchannel.proto

package org.bitcoin.paymentchannel;

public final class Protos {
  private Protos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface TwoWayChannelMessageOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.TwoWayChannelMessage)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     * @return Whether the type field is set.
     */
    boolean hasType();
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     * @return The type.
     */
    org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType();

    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     * @return Whether the clientVersion field is set.
     */
    boolean hasClientVersion();
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     * @return The clientVersion.
     */
    org.bitcoin.paymentchannel.Protos.ClientVersion getClientVersion();

    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     * @return Whether the serverVersion field is set.
     */
    boolean hasServerVersion();
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     * @return The serverVersion.
     */
    org.bitcoin.paymentchannel.Protos.ServerVersion getServerVersion();

    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     * @return Whether the initiate field is set.
     */
    boolean hasInitiate();
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     * @return The initiate.
     */
    org.bitcoin.paymentchannel.Protos.Initiate getInitiate();

    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     * @return Whether the provideRefund field is set.
     */
    boolean hasProvideRefund();
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     * @return The provideRefund.
     */
    org.bitcoin.paymentchannel.Protos.ProvideRefund getProvideRefund();

    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     * @return Whether the returnRefund field is set.
     */
    boolean hasReturnRefund();
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     * @return The returnRefund.
     */
    org.bitcoin.paymentchannel.Protos.ReturnRefund getReturnRefund();

    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     * @return Whether the provideContract field is set.
     */
    boolean hasProvideContract();
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     * @return The provideContract.
     */
    org.bitcoin.paymentchannel.Protos.ProvideContract getProvideContract();

    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     * @return Whether the updatePayment field is set.
     */
    boolean hasUpdatePayment();
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     * @return The updatePayment.
     */
    org.bitcoin.paymentchannel.Protos.UpdatePayment getUpdatePayment();

    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     * @return Whether the paymentAck field is set.
     */
    boolean hasPaymentAck();
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     * @return The paymentAck.
     */
    org.bitcoin.paymentchannel.Protos.PaymentAck getPaymentAck();

    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     * @return Whether the settlement field is set.
     */
    boolean hasSettlement();
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     * @return The settlement.
     */
    org.bitcoin.paymentchannel.Protos.Settlement getSettlement();

    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     * @return Whether the error field is set.
     */
    boolean hasError();
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     * @return The error.
     */
    org.bitcoin.paymentchannel.Protos.Error getError();
  }
  /**
   * <pre>
   * This message is designed to be either sent raw over the network (e.g. length prefixed) or embedded inside another
   * protocol that is being extended to support micropayments. In this file "primary" typically can be read as "client"
   * and "secondary" as "server".
   * </pre>
   *
   * Protobuf type {@code paymentchannels.TwoWayChannelMessage}
   */
  public  static final class TwoWayChannelMessage extends
      com.google.protobuf.GeneratedMessageLite<
          TwoWayChannelMessage, TwoWayChannelMessage.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.TwoWayChannelMessage)
      TwoWayChannelMessageOrBuilder {
    private TwoWayChannelMessage() {
      type_ = 1;
    }
    /**
     * Protobuf enum {@code paymentchannels.TwoWayChannelMessage.MessageType}
     */
    public enum MessageType
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      CLIENT_VERSION(1),
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      SERVER_VERSION(2),
      /**
       * <code>INITIATE = 3;</code>
       */
      INITIATE(3),
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      PROVIDE_REFUND(4),
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      RETURN_REFUND(5),
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      PROVIDE_CONTRACT(6),
      /**
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       *
       * <code>CHANNEL_OPEN = 7;</code>
       */
      CHANNEL_OPEN(7),
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      UPDATE_PAYMENT(8),
      /**
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       *
       * <code>PAYMENT_ACK = 11;</code>
       */
      PAYMENT_ACK(11),
      /**
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       *
       * <code>CLOSE = 9;</code>
       */
      CLOSE(9),
      /**
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       *
       * <code>ERROR = 10;</code>
       */
      ERROR(10),
      ;

      /**
       * <code>CLIENT_VERSION = 1;</code>
       */
      public static final int CLIENT_VERSION_VALUE = 1;
      /**
       * <code>SERVER_VERSION = 2;</code>
       */
      public static final int SERVER_VERSION_VALUE = 2;
      /**
       * <code>INITIATE = 3;</code>
       */
      public static final int INITIATE_VALUE = 3;
      /**
       * <code>PROVIDE_REFUND = 4;</code>
       */
      public static final int PROVIDE_REFUND_VALUE = 4;
      /**
       * <code>RETURN_REFUND = 5;</code>
       */
      public static final int RETURN_REFUND_VALUE = 5;
      /**
       * <code>PROVIDE_CONTRACT = 6;</code>
       */
      public static final int PROVIDE_CONTRACT_VALUE = 6;
      /**
       * <pre>
       * Note that there are no optional fields set for CHANNEL_OPEN, it is sent from the
       * secondary to the primary to indicate that the provided contract was received,
       * verified, and broadcast successfully and the primary can now provide UPDATE messages
       * at will to begin paying secondary. If the channel is interrupted after the
       * CHANNEL_OPEN message (ie closed without an explicit CLOSE or ERROR) the primary may
       * reopen the channel by setting the contract transaction hash in its CLIENT_VERSION
       * message.
       * </pre>
       *
       * <code>CHANNEL_OPEN = 7;</code>
       */
      public static final int CHANNEL_OPEN_VALUE = 7;
      /**
       * <code>UPDATE_PAYMENT = 8;</code>
       */
      public static final int UPDATE_PAYMENT_VALUE = 8;
      /**
       * <pre>
       * Sent by the server to the client after an UPDATE_PAYMENT message is successfully processed.
       * </pre>
       *
       * <code>PAYMENT_ACK = 11;</code>
       */
      public static final int PAYMENT_ACK_VALUE = 11;
      /**
       * <pre>
       * Either side can send this message. If the client sends it to the server, then the server
       * takes the most recent signature it received in an UPDATE_PAYMENT and uses it to create a
       * valid transaction, which it then broadcasts on the network.
       * Once broadcast is complete, it sends back another CLOSE message with the settlement field set, containing
       * the final state of the contract.
       * The server is allowed to initiate settlement whenever it wants, in which case the client will
       * asynchronously receive a CLOSE message with the settlement field set. The server is also allowed
       * to send a CLOSE to mark the end of a connection without any settlement taking place, in which
       * case this is just an equivalent to a TCP FIN packet. An explicit end-of-protocol markers can be
       * useful when this protocol is embedded inside another.
       * </pre>
       *
       * <code>CLOSE = 9;</code>
       */
      public static final int CLOSE_VALUE = 9;
      /**
       * <pre>
       * Used to indicate an error condition.
       * Both parties should make an effort to send either an ERROR or a CLOSE immediately
       * before closing the socket (unless they just received an ERROR or a CLOSE). This is important
       * because the protocol may not run over TCP.
       * </pre>
       *
       * <code>ERROR = 10;</code>
       */
      public static final int ERROR_VALUE = 10;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static MessageType valueOf(int value) {
        return forNumber(value);
      }

      public static MessageType forNumber(int value) {
        switch (value) {
          case 1: return CLIENT_VERSION;
          case 2: return SERVER_VERSION;
          case 3: return INITIATE;
          case 4: return PROVIDE_REFUND;
          case 5: return RETURN_REFUND;
          case 6: return PROVIDE_CONTRACT;
          case 7: return CHANNEL_OPEN;
          case 8: return UPDATE_PAYMENT;
          case 11: return PAYMENT_ACK;
          case 9: return CLOSE;
          case 10: return ERROR;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<MessageType>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          MessageType> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<MessageType>() {
              @java.lang.Override
              public MessageType findValueByNumber(int number) {
                return MessageType.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return MessageTypeVerifier.INSTANCE;
      }

      private static final class MessageTypeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new MessageTypeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return MessageType.forNumber(number) != null;
              }
            };

      private final int value;

      private MessageType(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:paymentchannels.TwoWayChannelMessage.MessageType)
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     * @return Whether the type field is set.
     */
    @java.lang.Override
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType() {
      org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType result = org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType.forNumber(type_);
      return result == null ? org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType.CLIENT_VERSION : result;
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     * @param value The type to set.
     */
    private void setType(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType value) {
      type_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <pre>
     * This is required so if a new message type is added in future, old software aborts trying
     * to read the message as early as possible. If the message doesn't parse, the socket should
     * be closed.
     * </pre>
     *
     * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
     */
    private void clearType() {
      bitField0_ = (bitField0_ & ~0x00000001);
      type_ = 1;
    }

    public static final int CLIENT_VERSION_FIELD_NUMBER = 2;
    private org.bitcoin.paymentchannel.Protos.ClientVersion clientVersion_;
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    @java.lang.Override
    public boolean hasClientVersion() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.ClientVersion getClientVersion() {
      return clientVersion_ == null ? org.bitcoin.paymentchannel.Protos.ClientVersion.getDefaultInstance() : clientVersion_;
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void setClientVersion(org.bitcoin.paymentchannel.Protos.ClientVersion value) {
      value.getClass();
  clientVersion_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeClientVersion(org.bitcoin.paymentchannel.Protos.ClientVersion value) {
      value.getClass();
  if (clientVersion_ != null &&
          clientVersion_ != org.bitcoin.paymentchannel.Protos.ClientVersion.getDefaultInstance()) {
        clientVersion_ =
          org.bitcoin.paymentchannel.Protos.ClientVersion.newBuilder(clientVersion_).mergeFrom(value).buildPartial();
      } else {
        clientVersion_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * Now one optional field for each message. Only the field specified by type should be read.
     * </pre>
     *
     * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
     */
    private void clearClientVersion() {  clientVersion_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int SERVER_VERSION_FIELD_NUMBER = 3;
    private org.bitcoin.paymentchannel.Protos.ServerVersion serverVersion_;
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    @java.lang.Override
    public boolean hasServerVersion() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.ServerVersion getServerVersion() {
      return serverVersion_ == null ? org.bitcoin.paymentchannel.Protos.ServerVersion.getDefaultInstance() : serverVersion_;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void setServerVersion(org.bitcoin.paymentchannel.Protos.ServerVersion value) {
      value.getClass();
  serverVersion_ = value;
      bitField0_ |= 0x00000004;
      }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeServerVersion(org.bitcoin.paymentchannel.Protos.ServerVersion value) {
      value.getClass();
  if (serverVersion_ != null &&
          serverVersion_ != org.bitcoin.paymentchannel.Protos.ServerVersion.getDefaultInstance()) {
        serverVersion_ =
          org.bitcoin.paymentchannel.Protos.ServerVersion.newBuilder(serverVersion_).mergeFrom(value).buildPartial();
      } else {
        serverVersion_ = value;
      }
      bitField0_ |= 0x00000004;
    }
    /**
     * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
     */
    private void clearServerVersion() {  serverVersion_ = null;
      bitField0_ = (bitField0_ & ~0x00000004);
    }

    public static final int INITIATE_FIELD_NUMBER = 4;
    private org.bitcoin.paymentchannel.Protos.Initiate initiate_;
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    @java.lang.Override
    public boolean hasInitiate() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.Initiate getInitiate() {
      return initiate_ == null ? org.bitcoin.paymentchannel.Protos.Initiate.getDefaultInstance() : initiate_;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void setInitiate(org.bitcoin.paymentchannel.Protos.Initiate value) {
      value.getClass();
  initiate_ = value;
      bitField0_ |= 0x00000008;
      }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeInitiate(org.bitcoin.paymentchannel.Protos.Initiate value) {
      value.getClass();
  if (initiate_ != null &&
          initiate_ != org.bitcoin.paymentchannel.Protos.Initiate.getDefaultInstance()) {
        initiate_ =
          org.bitcoin.paymentchannel.Protos.Initiate.newBuilder(initiate_).mergeFrom(value).buildPartial();
      } else {
        initiate_ = value;
      }
      bitField0_ |= 0x00000008;
    }
    /**
     * <code>optional .paymentchannels.Initiate initiate = 4;</code>
     */
    private void clearInitiate() {  initiate_ = null;
      bitField0_ = (bitField0_ & ~0x00000008);
    }

    public static final int PROVIDE_REFUND_FIELD_NUMBER = 5;
    private org.bitcoin.paymentchannel.Protos.ProvideRefund provideRefund_;
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    @java.lang.Override
    public boolean hasProvideRefund() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.ProvideRefund getProvideRefund() {
      return provideRefund_ == null ? org.bitcoin.paymentchannel.Protos.ProvideRefund.getDefaultInstance() : provideRefund_;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void setProvideRefund(org.bitcoin.paymentchannel.Protos.ProvideRefund value) {
      value.getClass();
  provideRefund_ = value;
      bitField0_ |= 0x00000010;
      }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeProvideRefund(org.bitcoin.paymentchannel.Protos.ProvideRefund value) {
      value.getClass();
  if (provideRefund_ != null &&
          provideRefund_ != org.bitcoin.paymentchannel.Protos.ProvideRefund.getDefaultInstance()) {
        provideRefund_ =
          org.bitcoin.paymentchannel.Protos.ProvideRefund.newBuilder(provideRefund_).mergeFrom(value).buildPartial();
      } else {
        provideRefund_ = value;
      }
      bitField0_ |= 0x00000010;
    }
    /**
     * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
     */
    private void clearProvideRefund() {  provideRefund_ = null;
      bitField0_ = (bitField0_ & ~0x00000010);
    }

    public static final int RETURN_REFUND_FIELD_NUMBER = 6;
    private org.bitcoin.paymentchannel.Protos.ReturnRefund returnRefund_;
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    @java.lang.Override
    public boolean hasReturnRefund() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.ReturnRefund getReturnRefund() {
      return returnRefund_ == null ? org.bitcoin.paymentchannel.Protos.ReturnRefund.getDefaultInstance() : returnRefund_;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void setReturnRefund(org.bitcoin.paymentchannel.Protos.ReturnRefund value) {
      value.getClass();
  returnRefund_ = value;
      bitField0_ |= 0x00000020;
      }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeReturnRefund(org.bitcoin.paymentchannel.Protos.ReturnRefund value) {
      value.getClass();
  if (returnRefund_ != null &&
          returnRefund_ != org.bitcoin.paymentchannel.Protos.ReturnRefund.getDefaultInstance()) {
        returnRefund_ =
          org.bitcoin.paymentchannel.Protos.ReturnRefund.newBuilder(returnRefund_).mergeFrom(value).buildPartial();
      } else {
        returnRefund_ = value;
      }
      bitField0_ |= 0x00000020;
    }
    /**
     * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
     */
    private void clearReturnRefund() {  returnRefund_ = null;
      bitField0_ = (bitField0_ & ~0x00000020);
    }

    public static final int PROVIDE_CONTRACT_FIELD_NUMBER = 7;
    private org.bitcoin.paymentchannel.Protos.ProvideContract provideContract_;
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    @java.lang.Override
    public boolean hasProvideContract() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.ProvideContract getProvideContract() {
      return provideContract_ == null ? org.bitcoin.paymentchannel.Protos.ProvideContract.getDefaultInstance() : provideContract_;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void setProvideContract(org.bitcoin.paymentchannel.Protos.ProvideContract value) {
      value.getClass();
  provideContract_ = value;
      bitField0_ |= 0x00000040;
      }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeProvideContract(org.bitcoin.paymentchannel.Protos.ProvideContract value) {
      value.getClass();
  if (provideContract_ != null &&
          provideContract_ != org.bitcoin.paymentchannel.Protos.ProvideContract.getDefaultInstance()) {
        provideContract_ =
          org.bitcoin.paymentchannel.Protos.ProvideContract.newBuilder(provideContract_).mergeFrom(value).buildPartial();
      } else {
        provideContract_ = value;
      }
      bitField0_ |= 0x00000040;
    }
    /**
     * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
     */
    private void clearProvideContract() {  provideContract_ = null;
      bitField0_ = (bitField0_ & ~0x00000040);
    }

    public static final int UPDATE_PAYMENT_FIELD_NUMBER = 8;
    private org.bitcoin.paymentchannel.Protos.UpdatePayment updatePayment_;
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    @java.lang.Override
    public boolean hasUpdatePayment() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.UpdatePayment getUpdatePayment() {
      return updatePayment_ == null ? org.bitcoin.paymentchannel.Protos.UpdatePayment.getDefaultInstance() : updatePayment_;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void setUpdatePayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
      value.getClass();
  updatePayment_ = value;
      bitField0_ |= 0x00000080;
      }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeUpdatePayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
      value.getClass();
  if (updatePayment_ != null &&
          updatePayment_ != org.bitcoin.paymentchannel.Protos.UpdatePayment.getDefaultInstance()) {
        updatePayment_ =
          org.bitcoin.paymentchannel.Protos.UpdatePayment.newBuilder(updatePayment_).mergeFrom(value).buildPartial();
      } else {
        updatePayment_ = value;
      }
      bitField0_ |= 0x00000080;
    }
    /**
     * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
     */
    private void clearUpdatePayment() {  updatePayment_ = null;
      bitField0_ = (bitField0_ & ~0x00000080);
    }

    public static final int PAYMENT_ACK_FIELD_NUMBER = 11;
    private org.bitcoin.paymentchannel.Protos.PaymentAck paymentAck_;
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    @java.lang.Override
    public boolean hasPaymentAck() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.PaymentAck getPaymentAck() {
      return paymentAck_ == null ? org.bitcoin.paymentchannel.Protos.PaymentAck.getDefaultInstance() : paymentAck_;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void setPaymentAck(org.bitcoin.paymentchannel.Protos.PaymentAck value) {
      value.getClass();
  paymentAck_ = value;
      bitField0_ |= 0x00000100;
      }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePaymentAck(org.bitcoin.paymentchannel.Protos.PaymentAck value) {
      value.getClass();
  if (paymentAck_ != null &&
          paymentAck_ != org.bitcoin.paymentchannel.Protos.PaymentAck.getDefaultInstance()) {
        paymentAck_ =
          org.bitcoin.paymentchannel.Protos.PaymentAck.newBuilder(paymentAck_).mergeFrom(value).buildPartial();
      } else {
        paymentAck_ = value;
      }
      bitField0_ |= 0x00000100;
    }
    /**
     * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
     */
    private void clearPaymentAck() {  paymentAck_ = null;
      bitField0_ = (bitField0_ & ~0x00000100);
    }

    public static final int SETTLEMENT_FIELD_NUMBER = 9;
    private org.bitcoin.paymentchannel.Protos.Settlement settlement_;
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    @java.lang.Override
    public boolean hasSettlement() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.Settlement getSettlement() {
      return settlement_ == null ? org.bitcoin.paymentchannel.Protos.Settlement.getDefaultInstance() : settlement_;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void setSettlement(org.bitcoin.paymentchannel.Protos.Settlement value) {
      value.getClass();
  settlement_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeSettlement(org.bitcoin.paymentchannel.Protos.Settlement value) {
      value.getClass();
  if (settlement_ != null &&
          settlement_ != org.bitcoin.paymentchannel.Protos.Settlement.getDefaultInstance()) {
        settlement_ =
          org.bitcoin.paymentchannel.Protos.Settlement.newBuilder(settlement_).mergeFrom(value).buildPartial();
      } else {
        settlement_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <code>optional .paymentchannels.Settlement settlement = 9;</code>
     */
    private void clearSettlement() {  settlement_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int ERROR_FIELD_NUMBER = 10;
    private org.bitcoin.paymentchannel.Protos.Error error_;
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    @java.lang.Override
    public boolean hasError() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.Error getError() {
      return error_ == null ? org.bitcoin.paymentchannel.Protos.Error.getDefaultInstance() : error_;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void setError(org.bitcoin.paymentchannel.Protos.Error value) {
      value.getClass();
  error_ = value;
      bitField0_ |= 0x00000400;
      }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeError(org.bitcoin.paymentchannel.Protos.Error value) {
      value.getClass();
  if (error_ != null &&
          error_ != org.bitcoin.paymentchannel.Protos.Error.getDefaultInstance()) {
        error_ =
          org.bitcoin.paymentchannel.Protos.Error.newBuilder(error_).mergeFrom(value).buildPartial();
      } else {
        error_ = value;
      }
      bitField0_ |= 0x00000400;
    }
    /**
     * <code>optional .paymentchannels.Error error = 10;</code>
     */
    private void clearError() {  error_ = null;
      bitField0_ = (bitField0_ & ~0x00000400);
    }

    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * This message is designed to be either sent raw over the network (e.g. length prefixed) or embedded inside another
     * protocol that is being extended to support micropayments. In this file "primary" typically can be read as "client"
     * and "secondary" as "server".
     * </pre>
     *
     * Protobuf type {@code paymentchannels.TwoWayChannelMessage}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.TwoWayChannelMessage)
        org.bitcoin.paymentchannel.Protos.TwoWayChannelMessageOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       * @return Whether the type field is set.
       */
      @java.lang.Override
      public boolean hasType() {
        return instance.hasType();
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType getType() {
        return instance.getType();
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setType(org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType value) {
        copyOnWrite();
        instance.setType(value);
        return this;
      }
      /**
       * <pre>
       * This is required so if a new message type is added in future, old software aborts trying
       * to read the message as early as possible. If the message doesn't parse, the socket should
       * be closed.
       * </pre>
       *
       * <code>required .paymentchannels.TwoWayChannelMessage.MessageType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        copyOnWrite();
        instance.clearType();
        return this;
      }

      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      @java.lang.Override
      public boolean hasClientVersion() {
        return instance.hasClientVersion();
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.ClientVersion getClientVersion() {
        return instance.getClientVersion();
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder setClientVersion(org.bitcoin.paymentchannel.Protos.ClientVersion value) {
        copyOnWrite();
        instance.setClientVersion(value);
        return this;
        }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder setClientVersion(
          org.bitcoin.paymentchannel.Protos.ClientVersion.Builder builderForValue) {
        copyOnWrite();
        instance.setClientVersion(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder mergeClientVersion(org.bitcoin.paymentchannel.Protos.ClientVersion value) {
        copyOnWrite();
        instance.mergeClientVersion(value);
        return this;
      }
      /**
       * <pre>
       * Now one optional field for each message. Only the field specified by type should be read.
       * </pre>
       *
       * <code>optional .paymentchannels.ClientVersion client_version = 2;</code>
       */
      public Builder clearClientVersion() {  copyOnWrite();
        instance.clearClientVersion();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      @java.lang.Override
      public boolean hasServerVersion() {
        return instance.hasServerVersion();
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.ServerVersion getServerVersion() {
        return instance.getServerVersion();
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder setServerVersion(org.bitcoin.paymentchannel.Protos.ServerVersion value) {
        copyOnWrite();
        instance.setServerVersion(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder setServerVersion(
          org.bitcoin.paymentchannel.Protos.ServerVersion.Builder builderForValue) {
        copyOnWrite();
        instance.setServerVersion(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder mergeServerVersion(org.bitcoin.paymentchannel.Protos.ServerVersion value) {
        copyOnWrite();
        instance.mergeServerVersion(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ServerVersion server_version = 3;</code>
       */
      public Builder clearServerVersion() {  copyOnWrite();
        instance.clearServerVersion();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      @java.lang.Override
      public boolean hasInitiate() {
        return instance.hasInitiate();
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.Initiate getInitiate() {
        return instance.getInitiate();
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder setInitiate(org.bitcoin.paymentchannel.Protos.Initiate value) {
        copyOnWrite();
        instance.setInitiate(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder setInitiate(
          org.bitcoin.paymentchannel.Protos.Initiate.Builder builderForValue) {
        copyOnWrite();
        instance.setInitiate(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder mergeInitiate(org.bitcoin.paymentchannel.Protos.Initiate value) {
        copyOnWrite();
        instance.mergeInitiate(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Initiate initiate = 4;</code>
       */
      public Builder clearInitiate() {  copyOnWrite();
        instance.clearInitiate();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      @java.lang.Override
      public boolean hasProvideRefund() {
        return instance.hasProvideRefund();
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.ProvideRefund getProvideRefund() {
        return instance.getProvideRefund();
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder setProvideRefund(org.bitcoin.paymentchannel.Protos.ProvideRefund value) {
        copyOnWrite();
        instance.setProvideRefund(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder setProvideRefund(
          org.bitcoin.paymentchannel.Protos.ProvideRefund.Builder builderForValue) {
        copyOnWrite();
        instance.setProvideRefund(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder mergeProvideRefund(org.bitcoin.paymentchannel.Protos.ProvideRefund value) {
        copyOnWrite();
        instance.mergeProvideRefund(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideRefund provide_refund = 5;</code>
       */
      public Builder clearProvideRefund() {  copyOnWrite();
        instance.clearProvideRefund();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      @java.lang.Override
      public boolean hasReturnRefund() {
        return instance.hasReturnRefund();
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.ReturnRefund getReturnRefund() {
        return instance.getReturnRefund();
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder setReturnRefund(org.bitcoin.paymentchannel.Protos.ReturnRefund value) {
        copyOnWrite();
        instance.setReturnRefund(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder setReturnRefund(
          org.bitcoin.paymentchannel.Protos.ReturnRefund.Builder builderForValue) {
        copyOnWrite();
        instance.setReturnRefund(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder mergeReturnRefund(org.bitcoin.paymentchannel.Protos.ReturnRefund value) {
        copyOnWrite();
        instance.mergeReturnRefund(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ReturnRefund return_refund = 6;</code>
       */
      public Builder clearReturnRefund() {  copyOnWrite();
        instance.clearReturnRefund();
        return this;
      }

      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      @java.lang.Override
      public boolean hasProvideContract() {
        return instance.hasProvideContract();
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.ProvideContract getProvideContract() {
        return instance.getProvideContract();
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder setProvideContract(org.bitcoin.paymentchannel.Protos.ProvideContract value) {
        copyOnWrite();
        instance.setProvideContract(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder setProvideContract(
          org.bitcoin.paymentchannel.Protos.ProvideContract.Builder builderForValue) {
        copyOnWrite();
        instance.setProvideContract(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder mergeProvideContract(org.bitcoin.paymentchannel.Protos.ProvideContract value) {
        copyOnWrite();
        instance.mergeProvideContract(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.ProvideContract provide_contract = 7;</code>
       */
      public Builder clearProvideContract() {  copyOnWrite();
        instance.clearProvideContract();
        return this;
      }

      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      @java.lang.Override
      public boolean hasUpdatePayment() {
        return instance.hasUpdatePayment();
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.UpdatePayment getUpdatePayment() {
        return instance.getUpdatePayment();
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder setUpdatePayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.setUpdatePayment(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder setUpdatePayment(
          org.bitcoin.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
        copyOnWrite();
        instance.setUpdatePayment(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder mergeUpdatePayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.mergeUpdatePayment(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.UpdatePayment update_payment = 8;</code>
       */
      public Builder clearUpdatePayment() {  copyOnWrite();
        instance.clearUpdatePayment();
        return this;
      }

      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      @java.lang.Override
      public boolean hasPaymentAck() {
        return instance.hasPaymentAck();
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.PaymentAck getPaymentAck() {
        return instance.getPaymentAck();
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder setPaymentAck(org.bitcoin.paymentchannel.Protos.PaymentAck value) {
        copyOnWrite();
        instance.setPaymentAck(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder setPaymentAck(
          org.bitcoin.paymentchannel.Protos.PaymentAck.Builder builderForValue) {
        copyOnWrite();
        instance.setPaymentAck(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder mergePaymentAck(org.bitcoin.paymentchannel.Protos.PaymentAck value) {
        copyOnWrite();
        instance.mergePaymentAck(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.PaymentAck payment_ack = 11;</code>
       */
      public Builder clearPaymentAck() {  copyOnWrite();
        instance.clearPaymentAck();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      @java.lang.Override
      public boolean hasSettlement() {
        return instance.hasSettlement();
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.Settlement getSettlement() {
        return instance.getSettlement();
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder setSettlement(org.bitcoin.paymentchannel.Protos.Settlement value) {
        copyOnWrite();
        instance.setSettlement(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder setSettlement(
          org.bitcoin.paymentchannel.Protos.Settlement.Builder builderForValue) {
        copyOnWrite();
        instance.setSettlement(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder mergeSettlement(org.bitcoin.paymentchannel.Protos.Settlement value) {
        copyOnWrite();
        instance.mergeSettlement(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Settlement settlement = 9;</code>
       */
      public Builder clearSettlement() {  copyOnWrite();
        instance.clearSettlement();
        return this;
      }

      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      @java.lang.Override
      public boolean hasError() {
        return instance.hasError();
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.Error getError() {
        return instance.getError();
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder setError(org.bitcoin.paymentchannel.Protos.Error value) {
        copyOnWrite();
        instance.setError(value);
        return this;
        }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder setError(
          org.bitcoin.paymentchannel.Protos.Error.Builder builderForValue) {
        copyOnWrite();
        instance.setError(builderForValue.build());
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder mergeError(org.bitcoin.paymentchannel.Protos.Error value) {
        copyOnWrite();
        instance.mergeError(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error error = 10;</code>
       */
      public Builder clearError() {  copyOnWrite();
        instance.clearError();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.TwoWayChannelMessage)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "type_",
              org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.MessageType.internalGetVerifier(),
              "clientVersion_",
              "serverVersion_",
              "initiate_",
              "provideRefund_",
              "returnRefund_",
              "provideContract_",
              "updatePayment_",
              "settlement_",
              "error_",
              "paymentAck_",
            };
            java.lang.String info =
                "\u0001\u000b\u0000\u0001\u0001\u000b\u000b\u0000\u0000\t\u0001\u150c\u0000\u0002" +
                "\u1409\u0001\u0003\u1409\u0002\u0004\u1409\u0003\u0005\u1409\u0004\u0006\u1409\u0005" +
                "\u0007\u1409\u0006\b\u1409\u0007\t\u1409\t\n\u1009\n\u000b\u1009\b";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.TwoWayChannelMessage)
    private static final org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage DEFAULT_INSTANCE;
    static {
      TwoWayChannelMessage defaultInstance = new TwoWayChannelMessage();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        TwoWayChannelMessage.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.TwoWayChannelMessage getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<TwoWayChannelMessage> PARSER;

    public static com.google.protobuf.Parser<TwoWayChannelMessage> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ClientVersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ClientVersion)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required int32 major = 1;</code>
     * @return Whether the major field is set.
     */
    boolean hasMajor();
    /**
     * <code>required int32 major = 1;</code>
     * @return The major.
     */
    int getMajor();

    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return Whether the minor field is set.
     */
    boolean hasMinor();
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return The minor.
     */
    int getMinor();

    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     * @return Whether the previousChannelContractHash field is set.
     */
    boolean hasPreviousChannelContractHash();
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     * @return The previousChannelContractHash.
     */
    com.google.protobuf.ByteString getPreviousChannelContractHash();

    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     * @return Whether the timeWindowSecs field is set.
     */
    boolean hasTimeWindowSecs();
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     * @return The timeWindowSecs.
     */
    long getTimeWindowSecs();
  }
  /**
   * <pre>
   * Sent by primary to secondary on opening the connection. If anything is received before this is
   * sent, the socket is closed.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ClientVersion}
   */
  public  static final class ClientVersion extends
      com.google.protobuf.GeneratedMessageLite<
          ClientVersion, ClientVersion.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ClientVersion)
      ClientVersionOrBuilder {
    private ClientVersion() {
      previousChannelContractHash_ = com.google.protobuf.ByteString.EMPTY;
      timeWindowSecs_ = 86340L;
    }
    private int bitField0_;
    public static final int MAJOR_FIELD_NUMBER = 1;
    private int major_;
    /**
     * <code>required int32 major = 1;</code>
     * @return Whether the major field is set.
     */
    @java.lang.Override
    public boolean hasMajor() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required int32 major = 1;</code>
     * @return The major.
     */
    @java.lang.Override
    public int getMajor() {
      return major_;
    }
    /**
     * <code>required int32 major = 1;</code>
     * @param value The major to set.
     */
    private void setMajor(int value) {
      bitField0_ |= 0x00000001;
      major_ = value;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void clearMajor() {
      bitField0_ = (bitField0_ & ~0x00000001);
      major_ = 0;
    }

    public static final int MINOR_FIELD_NUMBER = 2;
    private int minor_;
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return Whether the minor field is set.
     */
    @java.lang.Override
    public boolean hasMinor() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return The minor.
     */
    @java.lang.Override
    public int getMinor() {
      return minor_;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @param value The minor to set.
     */
    private void setMinor(int value) {
      bitField0_ |= 0x00000002;
      minor_ = value;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void clearMinor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minor_ = 0;
    }

    public static final int PREVIOUS_CHANNEL_CONTRACT_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString previousChannelContractHash_;
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     * @return Whether the previousChannelContractHash field is set.
     */
    @java.lang.Override
    public boolean hasPreviousChannelContractHash() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     * @return The previousChannelContractHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPreviousChannelContractHash() {
      return previousChannelContractHash_;
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     * @param value The previousChannelContractHash to set.
     */
    private void setPreviousChannelContractHash(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      previousChannelContractHash_ = value;
    }
    /**
     * <pre>
     * The hash of the multisig contract of a previous channel. This indicates that the primary
     * wishes to reopen the given channel. If the server is willing to reopen it, it simply
     * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
     * follows SERVER_VERSION with an Initiate representing a new channel
     * </pre>
     *
     * <code>optional bytes previous_channel_contract_hash = 3;</code>
     */
    private void clearPreviousChannelContractHash() {
      bitField0_ = (bitField0_ & ~0x00000004);
      previousChannelContractHash_ = getDefaultInstance().getPreviousChannelContractHash();
    }

    public static final int TIME_WINDOW_SECS_FIELD_NUMBER = 4;
    private long timeWindowSecs_;
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     * @return Whether the timeWindowSecs field is set.
     */
    @java.lang.Override
    public boolean hasTimeWindowSecs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     * @return The timeWindowSecs.
     */
    @java.lang.Override
    public long getTimeWindowSecs() {
      return timeWindowSecs_;
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     * @param value The timeWindowSecs to set.
     */
    private void setTimeWindowSecs(long value) {
      bitField0_ |= 0x00000008;
      timeWindowSecs_ = value;
    }
    /**
     * <pre>
     * How many seconds should the channel be open, only used when a new channel is created.
     * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
     * </pre>
     *
     * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
     */
    private void clearTimeWindowSecs() {
      bitField0_ = (bitField0_ & ~0x00000008);
      timeWindowSecs_ = 86340L;
    }

    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ClientVersion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.ClientVersion prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Sent by primary to secondary on opening the connection. If anything is received before this is
     * sent, the socket is closed.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ClientVersion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.ClientVersion, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ClientVersion)
        org.bitcoin.paymentchannel.Protos.ClientVersionOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.ClientVersion.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required int32 major = 1;</code>
       * @return Whether the major field is set.
       */
      @java.lang.Override
      public boolean hasMajor() {
        return instance.hasMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       * @return The major.
       */
      @java.lang.Override
      public int getMajor() {
        return instance.getMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       * @param value The major to set.
       * @return This builder for chaining.
       */
      public Builder setMajor(int value) {
        copyOnWrite();
        instance.setMajor(value);
        return this;
      }
      /**
       * <code>required int32 major = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMajor() {
        copyOnWrite();
        instance.clearMajor();
        return this;
      }

      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return Whether the minor field is set.
       */
      @java.lang.Override
      public boolean hasMinor() {
        return instance.hasMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return The minor.
       */
      @java.lang.Override
      public int getMinor() {
        return instance.getMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @param value The minor to set.
       * @return This builder for chaining.
       */
      public Builder setMinor(int value) {
        copyOnWrite();
        instance.setMinor(value);
        return this;
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinor() {
        copyOnWrite();
        instance.clearMinor();
        return this;
      }

      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       * @return Whether the previousChannelContractHash field is set.
       */
      @java.lang.Override
      public boolean hasPreviousChannelContractHash() {
        return instance.hasPreviousChannelContractHash();
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       * @return The previousChannelContractHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPreviousChannelContractHash() {
        return instance.getPreviousChannelContractHash();
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       * @param value The previousChannelContractHash to set.
       * @return This builder for chaining.
       */
      public Builder setPreviousChannelContractHash(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setPreviousChannelContractHash(value);
        return this;
      }
      /**
       * <pre>
       * The hash of the multisig contract of a previous channel. This indicates that the primary
       * wishes to reopen the given channel. If the server is willing to reopen it, it simply
       * responds with a SERVER_VERSION and then immediately sends a CHANNEL_OPEN, it otherwise
       * follows SERVER_VERSION with an Initiate representing a new channel
       * </pre>
       *
       * <code>optional bytes previous_channel_contract_hash = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreviousChannelContractHash() {
        copyOnWrite();
        instance.clearPreviousChannelContractHash();
        return this;
      }

      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       * @return Whether the timeWindowSecs field is set.
       */
      @java.lang.Override
      public boolean hasTimeWindowSecs() {
        return instance.hasTimeWindowSecs();
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       * @return The timeWindowSecs.
       */
      @java.lang.Override
      public long getTimeWindowSecs() {
        return instance.getTimeWindowSecs();
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       * @param value The timeWindowSecs to set.
       * @return This builder for chaining.
       */
      public Builder setTimeWindowSecs(long value) {
        copyOnWrite();
        instance.setTimeWindowSecs(value);
        return this;
      }
      /**
       * <pre>
       * How many seconds should the channel be open, only used when a new channel is created.
       * Defaults to 24 h minus 60 seconds, 24*60*60 - 60
       * </pre>
       *
       * <code>optional uint64 time_window_secs = 4 [default = 86340];</code>
       * @return This builder for chaining.
       */
      public Builder clearTimeWindowSecs() {
        copyOnWrite();
        instance.clearTimeWindowSecs();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ClientVersion)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.ClientVersion();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "major_",
              "minor_",
              "previousChannelContractHash_",
              "timeWindowSecs_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0001\u0001\u1504\u0000\u0002" +
                "\u1004\u0001\u0003\u100a\u0002\u0004\u1003\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.ClientVersion> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.ClientVersion.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.ClientVersion>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ClientVersion)
    private static final org.bitcoin.paymentchannel.Protos.ClientVersion DEFAULT_INSTANCE;
    static {
      ClientVersion defaultInstance = new ClientVersion();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ClientVersion.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.ClientVersion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ClientVersion> PARSER;

    public static com.google.protobuf.Parser<ClientVersion> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ServerVersionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ServerVersion)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required int32 major = 1;</code>
     * @return Whether the major field is set.
     */
    boolean hasMajor();
    /**
     * <code>required int32 major = 1;</code>
     * @return The major.
     */
    int getMajor();

    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return Whether the minor field is set.
     */
    boolean hasMinor();
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return The minor.
     */
    int getMinor();
  }
  /**
   * <pre>
   * Send by secondary to primary upon receiving the ClientVersion message. If it is willing to
   * speak the given major version, it sends back the same major version and the minor version it
   * speaks. If it is not, it may send back a lower major version representing the highest version
   * it is willing to speak, or sends a NO_ACCEPTABLE_VERSION Error. If the secondary sends back a
   * lower major version, the secondary should either expect to continue with that version, or
   * should immediately close the connection with a NO_ACCEPTABLE_VERSION Error. Backwards
   * incompatible changes to the protocol bump the major version. Extensions bump the minor version
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ServerVersion}
   */
  public  static final class ServerVersion extends
      com.google.protobuf.GeneratedMessageLite<
          ServerVersion, ServerVersion.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ServerVersion)
      ServerVersionOrBuilder {
    private ServerVersion() {
    }
    private int bitField0_;
    public static final int MAJOR_FIELD_NUMBER = 1;
    private int major_;
    /**
     * <code>required int32 major = 1;</code>
     * @return Whether the major field is set.
     */
    @java.lang.Override
    public boolean hasMajor() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required int32 major = 1;</code>
     * @return The major.
     */
    @java.lang.Override
    public int getMajor() {
      return major_;
    }
    /**
     * <code>required int32 major = 1;</code>
     * @param value The major to set.
     */
    private void setMajor(int value) {
      bitField0_ |= 0x00000001;
      major_ = value;
    }
    /**
     * <code>required int32 major = 1;</code>
     */
    private void clearMajor() {
      bitField0_ = (bitField0_ & ~0x00000001);
      major_ = 0;
    }

    public static final int MINOR_FIELD_NUMBER = 2;
    private int minor_;
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return Whether the minor field is set.
     */
    @java.lang.Override
    public boolean hasMinor() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @return The minor.
     */
    @java.lang.Override
    public int getMinor() {
      return minor_;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     * @param value The minor to set.
     */
    private void setMinor(int value) {
      bitField0_ |= 0x00000002;
      minor_ = value;
    }
    /**
     * <code>optional int32 minor = 2 [default = 0];</code>
     */
    private void clearMinor() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minor_ = 0;
    }

    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ServerVersion parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.ServerVersion prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Send by secondary to primary upon receiving the ClientVersion message. If it is willing to
     * speak the given major version, it sends back the same major version and the minor version it
     * speaks. If it is not, it may send back a lower major version representing the highest version
     * it is willing to speak, or sends a NO_ACCEPTABLE_VERSION Error. If the secondary sends back a
     * lower major version, the secondary should either expect to continue with that version, or
     * should immediately close the connection with a NO_ACCEPTABLE_VERSION Error. Backwards
     * incompatible changes to the protocol bump the major version. Extensions bump the minor version
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ServerVersion}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.ServerVersion, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ServerVersion)
        org.bitcoin.paymentchannel.Protos.ServerVersionOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.ServerVersion.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required int32 major = 1;</code>
       * @return Whether the major field is set.
       */
      @java.lang.Override
      public boolean hasMajor() {
        return instance.hasMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       * @return The major.
       */
      @java.lang.Override
      public int getMajor() {
        return instance.getMajor();
      }
      /**
       * <code>required int32 major = 1;</code>
       * @param value The major to set.
       * @return This builder for chaining.
       */
      public Builder setMajor(int value) {
        copyOnWrite();
        instance.setMajor(value);
        return this;
      }
      /**
       * <code>required int32 major = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMajor() {
        copyOnWrite();
        instance.clearMajor();
        return this;
      }

      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return Whether the minor field is set.
       */
      @java.lang.Override
      public boolean hasMinor() {
        return instance.hasMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return The minor.
       */
      @java.lang.Override
      public int getMinor() {
        return instance.getMinor();
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @param value The minor to set.
       * @return This builder for chaining.
       */
      public Builder setMinor(int value) {
        copyOnWrite();
        instance.setMinor(value);
        return this;
      }
      /**
       * <code>optional int32 minor = 2 [default = 0];</code>
       * @return This builder for chaining.
       */
      public Builder clearMinor() {
        copyOnWrite();
        instance.clearMinor();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ServerVersion)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.ServerVersion();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "major_",
              "minor_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0001\u0001\u1504\u0000\u0002" +
                "\u1004\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.ServerVersion> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.ServerVersion.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.ServerVersion>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ServerVersion)
    private static final org.bitcoin.paymentchannel.Protos.ServerVersion DEFAULT_INSTANCE;
    static {
      ServerVersion defaultInstance = new ServerVersion();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ServerVersion.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.ServerVersion getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ServerVersion> PARSER;

    public static com.google.protobuf.Parser<ServerVersion> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface InitiateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Initiate)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return Whether the multisigKey field is set.
     */
    boolean hasMultisigKey();
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return The multisigKey.
     */
    com.google.protobuf.ByteString getMultisigKey();

    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     * @return Whether the minAcceptedChannelSize field is set.
     */
    boolean hasMinAcceptedChannelSize();
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     * @return The minAcceptedChannelSize.
     */
    long getMinAcceptedChannelSize();

    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     * @return Whether the expireTimeSecs field is set.
     */
    boolean hasExpireTimeSecs();
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     * @return The expireTimeSecs.
     */
    long getExpireTimeSecs();

    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     * @return Whether the minPayment field is set.
     */
    boolean hasMinPayment();
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     * @return The minPayment.
     */
    long getMinPayment();
  }
  /**
   * <pre>
   * Sent from server to client once version nego is done.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.Initiate}
   */
  public  static final class Initiate extends
      com.google.protobuf.GeneratedMessageLite<
          Initiate, Initiate.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Initiate)
      InitiateOrBuilder {
    private Initiate() {
      multisigKey_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int MULTISIG_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString multisigKey_;
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return Whether the multisigKey field is set.
     */
    @java.lang.Override
    public boolean hasMultisigKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return The multisigKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMultisigKey() {
      return multisigKey_;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @param value The multisigKey to set.
     */
    private void setMultisigKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      multisigKey_ = value;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted. It is used only in the creation of the multisig contract, as outputs are
     * created entirely by the secondary
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void clearMultisigKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      multisigKey_ = getDefaultInstance().getMultisigKey();
    }

    public static final int MIN_ACCEPTED_CHANNEL_SIZE_FIELD_NUMBER = 2;
    private long minAcceptedChannelSize_;
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     * @return Whether the minAcceptedChannelSize field is set.
     */
    @java.lang.Override
    public boolean hasMinAcceptedChannelSize() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     * @return The minAcceptedChannelSize.
     */
    @java.lang.Override
    public long getMinAcceptedChannelSize() {
      return minAcceptedChannelSize_;
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     * @param value The minAcceptedChannelSize to set.
     */
    private void setMinAcceptedChannelSize(long value) {
      bitField0_ |= 0x00000002;
      minAcceptedChannelSize_ = value;
    }
    /**
     * <pre>
     * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
     * size it's willing to accept here. This can be lower to trade off resources against
     * security but shouldn't be so low the transactions get rejected by the network as spam.
     * Zero isn't a sensible value to have here, so we make the field required.
     * </pre>
     *
     * <code>required uint64 min_accepted_channel_size = 2;</code>
     */
    private void clearMinAcceptedChannelSize() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minAcceptedChannelSize_ = 0L;
    }

    public static final int EXPIRE_TIME_SECS_FIELD_NUMBER = 3;
    private long expireTimeSecs_;
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     * @return Whether the expireTimeSecs field is set.
     */
    @java.lang.Override
    public boolean hasExpireTimeSecs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     * @return The expireTimeSecs.
     */
    @java.lang.Override
    public long getExpireTimeSecs() {
      return expireTimeSecs_;
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     * @param value The expireTimeSecs to set.
     */
    private void setExpireTimeSecs(long value) {
      bitField0_ |= 0x00000004;
      expireTimeSecs_ = value;
    }
    /**
     * <pre>
     * Rough UNIX time for when the channel expires. This is determined by the block header
     * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
     * Channels could also be specified in terms of block heights but then how do you know the
     * current chain height if you don't have internet access? Trust the server? Probably opens up
     * attack vectors. We can assume the client has an independent clock, however. If the client
     * considers this value too far off (eg more than a day), it may send an ERROR and close the
     * channel.
     * </pre>
     *
     * <code>required uint64 expire_time_secs = 3;</code>
     */
    private void clearExpireTimeSecs() {
      bitField0_ = (bitField0_ & ~0x00000004);
      expireTimeSecs_ = 0L;
    }

    public static final int MIN_PAYMENT_FIELD_NUMBER = 4;
    private long minPayment_;
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     * @return Whether the minPayment field is set.
     */
    @java.lang.Override
    public boolean hasMinPayment() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     * @return The minPayment.
     */
    @java.lang.Override
    public long getMinPayment() {
      return minPayment_;
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     * @param value The minPayment to set.
     */
    private void setMinPayment(long value) {
      bitField0_ |= 0x00000008;
      minPayment_ = value;
    }
    /**
     * <pre>
     * The amount of money the server requires for the initial payment. The act of opening a channel
     * always transfers some quantity of money to the server: it's impossible to have a channel with
     * zero value transferred. This rule ensures that you can't get a channel that can't be settled
     * due to having paid under the dust limit. Because the dust limit will float in future, the
     * server tells the client what it thinks it is, and the client is supposed to sanity check this
     * value.
     * </pre>
     *
     * <code>required uint64 min_payment = 4;</code>
     */
    private void clearMinPayment() {
      bitField0_ = (bitField0_ & ~0x00000008);
      minPayment_ = 0L;
    }

    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Initiate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.Initiate prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Sent from server to client once version nego is done.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.Initiate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.Initiate, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Initiate)
        org.bitcoin.paymentchannel.Protos.InitiateOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.Initiate.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return Whether the multisigKey field is set.
       */
      @java.lang.Override
      public boolean hasMultisigKey() {
        return instance.hasMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return The multisigKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMultisigKey() {
        return instance.getMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @param value The multisigKey to set.
       * @return This builder for chaining.
       */
      public Builder setMultisigKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultisigKey(value);
        return this;
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted. It is used only in the creation of the multisig contract, as outputs are
       * created entirely by the secondary
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMultisigKey() {
        copyOnWrite();
        instance.clearMultisigKey();
        return this;
      }

      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       * @return Whether the minAcceptedChannelSize field is set.
       */
      @java.lang.Override
      public boolean hasMinAcceptedChannelSize() {
        return instance.hasMinAcceptedChannelSize();
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       * @return The minAcceptedChannelSize.
       */
      @java.lang.Override
      public long getMinAcceptedChannelSize() {
        return instance.getMinAcceptedChannelSize();
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       * @param value The minAcceptedChannelSize to set.
       * @return This builder for chaining.
       */
      public Builder setMinAcceptedChannelSize(long value) {
        copyOnWrite();
        instance.setMinAcceptedChannelSize(value);
        return this;
      }
      /**
       * <pre>
       * Once a channel is exhausted a new one must be set up. So secondary indicates the minimum
       * size it's willing to accept here. This can be lower to trade off resources against
       * security but shouldn't be so low the transactions get rejected by the network as spam.
       * Zero isn't a sensible value to have here, so we make the field required.
       * </pre>
       *
       * <code>required uint64 min_accepted_channel_size = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinAcceptedChannelSize() {
        copyOnWrite();
        instance.clearMinAcceptedChannelSize();
        return this;
      }

      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       * @return Whether the expireTimeSecs field is set.
       */
      @java.lang.Override
      public boolean hasExpireTimeSecs() {
        return instance.hasExpireTimeSecs();
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       * @return The expireTimeSecs.
       */
      @java.lang.Override
      public long getExpireTimeSecs() {
        return instance.getExpireTimeSecs();
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       * @param value The expireTimeSecs to set.
       * @return This builder for chaining.
       */
      public Builder setExpireTimeSecs(long value) {
        copyOnWrite();
        instance.setExpireTimeSecs(value);
        return this;
      }
      /**
       * <pre>
       * Rough UNIX time for when the channel expires. This is determined by the block header
       * timestamps which can be very inaccurate when miners use the obsolete RollNTime hack.
       * Channels could also be specified in terms of block heights but then how do you know the
       * current chain height if you don't have internet access? Trust the server? Probably opens up
       * attack vectors. We can assume the client has an independent clock, however. If the client
       * considers this value too far off (eg more than a day), it may send an ERROR and close the
       * channel.
       * </pre>
       *
       * <code>required uint64 expire_time_secs = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpireTimeSecs() {
        copyOnWrite();
        instance.clearExpireTimeSecs();
        return this;
      }

      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       * @return Whether the minPayment field is set.
       */
      @java.lang.Override
      public boolean hasMinPayment() {
        return instance.hasMinPayment();
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       * @return The minPayment.
       */
      @java.lang.Override
      public long getMinPayment() {
        return instance.getMinPayment();
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       * @param value The minPayment to set.
       * @return This builder for chaining.
       */
      public Builder setMinPayment(long value) {
        copyOnWrite();
        instance.setMinPayment(value);
        return this;
      }
      /**
       * <pre>
       * The amount of money the server requires for the initial payment. The act of opening a channel
       * always transfers some quantity of money to the server: it's impossible to have a channel with
       * zero value transferred. This rule ensures that you can't get a channel that can't be settled
       * due to having paid under the dust limit. Because the dust limit will float in future, the
       * server tells the client what it thinks it is, and the client is supposed to sanity check this
       * value.
       * </pre>
       *
       * <code>required uint64 min_payment = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearMinPayment() {
        copyOnWrite();
        instance.clearMinPayment();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Initiate)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.Initiate();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "multisigKey_",
              "minAcceptedChannelSize_",
              "expireTimeSecs_",
              "minPayment_",
            };
            java.lang.String info =
                "\u0001\u0004\u0000\u0001\u0001\u0004\u0004\u0000\u0000\u0004\u0001\u150a\u0000\u0002" +
                "\u1503\u0001\u0003\u1503\u0002\u0004\u1503\u0003";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.Initiate> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.Initiate.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.Initiate>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Initiate)
    private static final org.bitcoin.paymentchannel.Protos.Initiate DEFAULT_INSTANCE;
    static {
      Initiate defaultInstance = new Initiate();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Initiate.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.Initiate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Initiate> PARSER;

    public static com.google.protobuf.Parser<Initiate> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ProvideRefundOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ProvideRefund)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return Whether the multisigKey field is set.
     */
    boolean hasMultisigKey();
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return The multisigKey.
     */
    com.google.protobuf.ByteString getMultisigKey();

    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     * @return Whether the tx field is set.
     */
    boolean hasTx();
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     * @return The tx.
     */
    com.google.protobuf.ByteString getTx();
  }
  /**
   * <pre>
   * Sent from primary to secondary after Initiate to begin the refund transaction signing.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ProvideRefund}
   */
  public  static final class ProvideRefund extends
      com.google.protobuf.GeneratedMessageLite<
          ProvideRefund, ProvideRefund.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ProvideRefund)
      ProvideRefundOrBuilder {
    private ProvideRefund() {
      multisigKey_ = com.google.protobuf.ByteString.EMPTY;
      tx_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int MULTISIG_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString multisigKey_;
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return Whether the multisigKey field is set.
     */
    @java.lang.Override
    public boolean hasMultisigKey() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @return The multisigKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getMultisigKey() {
      return multisigKey_;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     * @param value The multisigKey to set.
     */
    private void setMultisigKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      multisigKey_ = value;
    }
    /**
     * <pre>
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>required bytes multisig_key = 1;</code>
     */
    private void clearMultisigKey() {
      bitField0_ = (bitField0_ & ~0x00000001);
      multisigKey_ = getDefaultInstance().getMultisigKey();
    }

    public static final int TX_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     * @return Whether the tx field is set.
     */
    @java.lang.Override
    public boolean hasTx() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     * @return The tx.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     * @param value The tx to set.
     */
    private void setTx(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      tx_ = value;
    }
    /**
     * <pre>
     * The serialized bytes of the return transaction in Satoshi format.
     * * It must have exactly one input which spends the multisig output (see ProvideContract for
     *   details of exactly what that output must look like). This output must have a sequence
     *   number of 0.
     * * It must have the lock time set to a time after the min_time_window_secs (from the
     *   Initiate message).
     * * It must have exactly one output which goes back to the primary.  This output's
     *   scriptPubKey will be reused to create payment transactions.
     * </pre>
     *
     * <code>required bytes tx = 2;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000002);
      tx_ = getDefaultInstance().getTx();
    }

    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideRefund parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.ProvideRefund prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Sent from primary to secondary after Initiate to begin the refund transaction signing.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ProvideRefund}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.ProvideRefund, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ProvideRefund)
        org.bitcoin.paymentchannel.Protos.ProvideRefundOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.ProvideRefund.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return Whether the multisigKey field is set.
       */
      @java.lang.Override
      public boolean hasMultisigKey() {
        return instance.hasMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return The multisigKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getMultisigKey() {
        return instance.getMultisigKey();
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @param value The multisigKey to set.
       * @return This builder for chaining.
       */
      public Builder setMultisigKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setMultisigKey(value);
        return this;
      }
      /**
       * <pre>
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>required bytes multisig_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMultisigKey() {
        copyOnWrite();
        instance.clearMultisigKey();
        return this;
      }

      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       * @return Whether the tx field is set.
       */
      @java.lang.Override
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       * @return The tx.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       * @param value The tx to set.
       * @return This builder for chaining.
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * The serialized bytes of the return transaction in Satoshi format.
       * * It must have exactly one input which spends the multisig output (see ProvideContract for
       *   details of exactly what that output must look like). This output must have a sequence
       *   number of 0.
       * * It must have the lock time set to a time after the min_time_window_secs (from the
       *   Initiate message).
       * * It must have exactly one output which goes back to the primary.  This output's
       *   scriptPubKey will be reused to create payment transactions.
       * </pre>
       *
       * <code>required bytes tx = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ProvideRefund)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.ProvideRefund();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "multisigKey_",
              "tx_",
            };
            java.lang.String info =
                "\u0001\u0002\u0000\u0001\u0001\u0002\u0002\u0000\u0000\u0002\u0001\u150a\u0000\u0002" +
                "\u150a\u0001";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.ProvideRefund> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.ProvideRefund.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.ProvideRefund>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ProvideRefund)
    private static final org.bitcoin.paymentchannel.Protos.ProvideRefund DEFAULT_INSTANCE;
    static {
      ProvideRefund defaultInstance = new ProvideRefund();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ProvideRefund.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.ProvideRefund getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ProvideRefund> PARSER;

    public static com.google.protobuf.Parser<ProvideRefund> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ReturnRefundOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ReturnRefund)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>required bytes signature = 1;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <code>required bytes signature = 1;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * <pre>
   * Sent from secondary to primary after it has done initial verification of the refund
   * transaction. Contains the primary's signature which is required to spend the multisig contract
   * to the refund transaction. Must be signed using SIGHASH_NONE|SIGHASH_ANYONECANPAY (and include
   * the postfix type byte) to allow the client to add any outputs/inputs it wants as long as the
   * input's sequence and transaction's nLockTime remain set.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ReturnRefund}
   */
  public  static final class ReturnRefund extends
      com.google.protobuf.GeneratedMessageLite<
          ReturnRefund, ReturnRefund.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ReturnRefund)
      ReturnRefundOrBuilder {
    private ReturnRefund() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int SIGNATURE_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString signature_;
    /**
     * <code>required bytes signature = 1;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>required bytes signature = 1;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <code>required bytes signature = 1;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      signature_ = value;
    }
    /**
     * <code>required bytes signature = 1;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000001);
      signature_ = getDefaultInstance().getSignature();
    }

    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ReturnRefund parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.ReturnRefund prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Sent from secondary to primary after it has done initial verification of the refund
     * transaction. Contains the primary's signature which is required to spend the multisig contract
     * to the refund transaction. Must be signed using SIGHASH_NONE|SIGHASH_ANYONECANPAY (and include
     * the postfix type byte) to allow the client to add any outputs/inputs it wants as long as the
     * input's sequence and transaction's nLockTime remain set.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ReturnRefund}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.ReturnRefund, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ReturnRefund)
        org.bitcoin.paymentchannel.Protos.ReturnRefundOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.ReturnRefund.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>required bytes signature = 1;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <code>required bytes signature = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ReturnRefund)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.ReturnRefund();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "signature_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0001\u0001\u150a\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.ReturnRefund> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.ReturnRefund.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.ReturnRefund>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ReturnRefund)
    private static final org.bitcoin.paymentchannel.Protos.ReturnRefund DEFAULT_INSTANCE;
    static {
      ReturnRefund defaultInstance = new ReturnRefund();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ReturnRefund.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.ReturnRefund getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ReturnRefund> PARSER;

    public static com.google.protobuf.Parser<ReturnRefund> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ProvideContractOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.ProvideContract)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     * @return Whether the tx field is set.
     */
    boolean hasTx();
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     * @return The tx.
     */
    com.google.protobuf.ByteString getTx();

    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     * @return Whether the initialPayment field is set.
     */
    boolean hasInitialPayment();
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     * @return The initialPayment.
     */
    org.bitcoin.paymentchannel.Protos.UpdatePayment getInitialPayment();

    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     * @return Whether the clientKey field is set.
     */
    boolean hasClientKey();
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     * @return The clientKey.
     */
    com.google.protobuf.ByteString getClientKey();
  }
  /**
   * <pre>
   * Sent from the primary to the secondary to complete initialization.
   * </pre>
   *
   * Protobuf type {@code paymentchannels.ProvideContract}
   */
  public  static final class ProvideContract extends
      com.google.protobuf.GeneratedMessageLite<
          ProvideContract, ProvideContract.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.ProvideContract)
      ProvideContractOrBuilder {
    private ProvideContract() {
      tx_ = com.google.protobuf.ByteString.EMPTY;
      clientKey_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TX_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     * @return Whether the tx field is set.
     */
    @java.lang.Override
    public boolean hasTx() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     * @return The tx.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     * @param value The tx to set.
     */
    private void setTx(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      tx_ = value;
    }
    /**
     * <pre>
     * The serialized bytes of the transaction in Satoshi format.
     * For version 1:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
     *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
     *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
     * For version 2:
     * * It must be signed and completely valid and ready for broadcast (ie it includes the
     *   necessary fees) TODO: tell the client how much fee it needs
     * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
     *   primary's and the second being the secondary's.
     * </pre>
     *
     * <code>required bytes tx = 1;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tx_ = getDefaultInstance().getTx();
    }

    public static final int INITIAL_PAYMENT_FIELD_NUMBER = 2;
    private org.bitcoin.paymentchannel.Protos.UpdatePayment initialPayment_;
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    @java.lang.Override
    public boolean hasInitialPayment() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.UpdatePayment getInitialPayment() {
      return initialPayment_ == null ? org.bitcoin.paymentchannel.Protos.UpdatePayment.getDefaultInstance() : initialPayment_;
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void setInitialPayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
      value.getClass();
  initialPayment_ = value;
      bitField0_ |= 0x00000002;
      }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeInitialPayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
      value.getClass();
  if (initialPayment_ != null &&
          initialPayment_ != org.bitcoin.paymentchannel.Protos.UpdatePayment.getDefaultInstance()) {
        initialPayment_ =
          org.bitcoin.paymentchannel.Protos.UpdatePayment.newBuilder(initialPayment_).mergeFrom(value).buildPartial();
      } else {
        initialPayment_ = value;
      }
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * To open the channel, an initial payment of the server-specified dust limit value must be
     * provided. This ensures that the channel is never in an un-settleable state due to either
     * no payment tx having been provided at all, or a payment that is smaller than the dust
     * limit being provided.
     * </pre>
     *
     * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
     */
    private void clearInitialPayment() {  initialPayment_ = null;
      bitField0_ = (bitField0_ & ~0x00000002);
    }

    public static final int CLIENT_KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString clientKey_;
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     * @return Whether the clientKey field is set.
     */
    @java.lang.Override
    public boolean hasClientKey() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     * @return The clientKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getClientKey() {
      return clientKey_;
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     * @param value The clientKey to set.
     */
    private void setClientKey(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      clientKey_ = value;
    }
    /**
     * <pre>
     * This field is added in protocol version 2 to send the client public key to the server.
     * In version 1 it isn't used.
     * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
     * are accepted.  It is only used in the creation of the multisig contract.
     * </pre>
     *
     * <code>optional bytes client_key = 3;</code>
     */
    private void clearClientKey() {
      bitField0_ = (bitField0_ & ~0x00000004);
      clientKey_ = getDefaultInstance().getClientKey();
    }

    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.ProvideContract parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.ProvideContract prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Sent from the primary to the secondary to complete initialization.
     * </pre>
     *
     * Protobuf type {@code paymentchannels.ProvideContract}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.ProvideContract, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.ProvideContract)
        org.bitcoin.paymentchannel.Protos.ProvideContractOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.ProvideContract.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       * @return Whether the tx field is set.
       */
      @java.lang.Override
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       * @return The tx.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       * @param value The tx to set.
       * @return This builder for chaining.
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * The serialized bytes of the transaction in Satoshi format.
       * For version 1:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a 2-of-2 multisig output with the first pubkey being the
       *   primary's and the second being the secondary's (ie the script must be exactly "OP_2
       *   ProvideRefund.multisig_key Initiate.multisig_key OP_2 OP_CHECKMULTISIG")
       * For version 2:
       * * It must be signed and completely valid and ready for broadcast (ie it includes the
       *   necessary fees) TODO: tell the client how much fee it needs
       * * Its first output must be a CHECKLOCKTIMEVERIFY output with the first pubkey being the
       *   primary's and the second being the secondary's.
       * </pre>
       *
       * <code>required bytes tx = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      @java.lang.Override
      public boolean hasInitialPayment() {
        return instance.hasInitialPayment();
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.UpdatePayment getInitialPayment() {
        return instance.getInitialPayment();
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder setInitialPayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.setInitialPayment(value);
        return this;
        }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder setInitialPayment(
          org.bitcoin.paymentchannel.Protos.UpdatePayment.Builder builderForValue) {
        copyOnWrite();
        instance.setInitialPayment(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder mergeInitialPayment(org.bitcoin.paymentchannel.Protos.UpdatePayment value) {
        copyOnWrite();
        instance.mergeInitialPayment(value);
        return this;
      }
      /**
       * <pre>
       * To open the channel, an initial payment of the server-specified dust limit value must be
       * provided. This ensures that the channel is never in an un-settleable state due to either
       * no payment tx having been provided at all, or a payment that is smaller than the dust
       * limit being provided.
       * </pre>
       *
       * <code>required .paymentchannels.UpdatePayment initial_payment = 2;</code>
       */
      public Builder clearInitialPayment() {  copyOnWrite();
        instance.clearInitialPayment();
        return this;
      }

      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       * @return Whether the clientKey field is set.
       */
      @java.lang.Override
      public boolean hasClientKey() {
        return instance.hasClientKey();
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       * @return The clientKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getClientKey() {
        return instance.getClientKey();
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       * @param value The clientKey to set.
       * @return This builder for chaining.
       */
      public Builder setClientKey(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setClientKey(value);
        return this;
      }
      /**
       * <pre>
       * This field is added in protocol version 2 to send the client public key to the server.
       * In version 1 it isn't used.
       * This must be a raw pubkey in regular ECDSA form. Both compressed and non-compressed forms
       * are accepted.  It is only used in the creation of the multisig contract.
       * </pre>
       *
       * <code>optional bytes client_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientKey() {
        copyOnWrite();
        instance.clearClientKey();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.ProvideContract)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.ProvideContract();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "tx_",
              "initialPayment_",
              "clientKey_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0002\u0001\u150a\u0000\u0002" +
                "\u1509\u0001\u0003\u100a\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.ProvideContract> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.ProvideContract.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.ProvideContract>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.ProvideContract)
    private static final org.bitcoin.paymentchannel.Protos.ProvideContract DEFAULT_INSTANCE;
    static {
      ProvideContract defaultInstance = new ProvideContract();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        ProvideContract.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.ProvideContract getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<ProvideContract> PARSER;

    public static com.google.protobuf.Parser<ProvideContract> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface UpdatePaymentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.UpdatePayment)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     * @return Whether the clientChangeValue field is set.
     */
    boolean hasClientChangeValue();
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     * @return The clientChangeValue.
     */
    long getClientChangeValue();

    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    boolean hasSignature();
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();

    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     * @return Whether the info field is set.
     */
    boolean hasInfo();
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     * @return The info.
     */
    com.google.protobuf.ByteString getInfo();
  }
  /**
   * <pre>
   * This message can only be used by the primary after it has received a CHANNEL_OPEN message. It
   * creates a new payment transaction. Note that we don't resubmit the entire TX, this is to avoid
   * (re)parsing bugs and overhead. The payment transaction is created by the primary by:
   * * Adding an input which spends the multisig contract
   * * Setting this input's scriptSig to the given signature and a new signature created by the
   *   primary (the primary should ensure the signature provided correctly spends the multisig
   *   contract)
   * * Adding an output who's scriptPubKey is the same as the refund output (the only output) in
   *   the refund transaction
   * * Setting this output's value to client_change_value (which must be lower than the most recent
   *   client_change_value and lower than the multisig contract's output value)
   * * Adding any number of additional outputs as desired (leaving sufficient fee, if necessary)
   * * Adding any number of additional inputs as desired (eg to add more fee)
   * </pre>
   *
   * Protobuf type {@code paymentchannels.UpdatePayment}
   */
  public  static final class UpdatePayment extends
      com.google.protobuf.GeneratedMessageLite<
          UpdatePayment, UpdatePayment.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.UpdatePayment)
      UpdatePaymentOrBuilder {
    private UpdatePayment() {
      signature_ = com.google.protobuf.ByteString.EMPTY;
      info_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int CLIENT_CHANGE_VALUE_FIELD_NUMBER = 1;
    private long clientChangeValue_;
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     * @return Whether the clientChangeValue field is set.
     */
    @java.lang.Override
    public boolean hasClientChangeValue() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     * @return The clientChangeValue.
     */
    @java.lang.Override
    public long getClientChangeValue() {
      return clientChangeValue_;
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     * @param value The clientChangeValue to set.
     */
    private void setClientChangeValue(long value) {
      bitField0_ |= 0x00000001;
      clientChangeValue_ = value;
    }
    /**
     * <pre>
     * The value which is sent back to the primary.  The rest of the multisig output is left for
     * the secondary to do with as they wish.
     * </pre>
     *
     * <code>required uint64 client_change_value = 1;</code>
     */
    private void clearClientChangeValue() {
      bitField0_ = (bitField0_ & ~0x00000001);
      clientChangeValue_ = 0L;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return Whether the signature field is set.
     */
    @java.lang.Override
    public boolean hasSignature() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     * @param value The signature to set.
     */
    private void setSignature(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      signature_ = value;
    }
    /**
     * <pre>
     * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
     * spends the primary's part of the multisig contract's output.  This signature only covers
     * the primary's refund output and thus the secondary is free to do what they wish with their
     * part of the multisig output.
     * </pre>
     *
     * <code>required bytes signature = 2;</code>
     */
    private void clearSignature() {
      bitField0_ = (bitField0_ & ~0x00000002);
      signature_ = getDefaultInstance().getSignature();
    }

    public static final int INFO_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString info_;
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     * @return Whether the info field is set.
     */
    @java.lang.Override
    public boolean hasInfo() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     * @return The info.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getInfo() {
      return info_;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     * @param value The info to set.
     */
    private void setInfo(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000004;
      info_ = value;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol.
     * </pre>
     *
     * <code>optional bytes info = 3;</code>
     */
    private void clearInfo() {
      bitField0_ = (bitField0_ & ~0x00000004);
      info_ = getDefaultInstance().getInfo();
    }

    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.UpdatePayment parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.UpdatePayment prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * This message can only be used by the primary after it has received a CHANNEL_OPEN message. It
     * creates a new payment transaction. Note that we don't resubmit the entire TX, this is to avoid
     * (re)parsing bugs and overhead. The payment transaction is created by the primary by:
     * * Adding an input which spends the multisig contract
     * * Setting this input's scriptSig to the given signature and a new signature created by the
     *   primary (the primary should ensure the signature provided correctly spends the multisig
     *   contract)
     * * Adding an output who's scriptPubKey is the same as the refund output (the only output) in
     *   the refund transaction
     * * Setting this output's value to client_change_value (which must be lower than the most recent
     *   client_change_value and lower than the multisig contract's output value)
     * * Adding any number of additional outputs as desired (leaving sufficient fee, if necessary)
     * * Adding any number of additional inputs as desired (eg to add more fee)
     * </pre>
     *
     * Protobuf type {@code paymentchannels.UpdatePayment}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.UpdatePayment, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.UpdatePayment)
        org.bitcoin.paymentchannel.Protos.UpdatePaymentOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.UpdatePayment.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       * @return Whether the clientChangeValue field is set.
       */
      @java.lang.Override
      public boolean hasClientChangeValue() {
        return instance.hasClientChangeValue();
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       * @return The clientChangeValue.
       */
      @java.lang.Override
      public long getClientChangeValue() {
        return instance.getClientChangeValue();
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       * @param value The clientChangeValue to set.
       * @return This builder for chaining.
       */
      public Builder setClientChangeValue(long value) {
        copyOnWrite();
        instance.setClientChangeValue(value);
        return this;
      }
      /**
       * <pre>
       * The value which is sent back to the primary.  The rest of the multisig output is left for
       * the secondary to do with as they wish.
       * </pre>
       *
       * <code>required uint64 client_change_value = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientChangeValue() {
        copyOnWrite();
        instance.clearClientChangeValue();
        return this;
      }

      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return Whether the signature field is set.
       */
      @java.lang.Override
      public boolean hasSignature() {
        return instance.hasSignature();
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return instance.getSignature();
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setSignature(value);
        return this;
      }
      /**
       * <pre>
       * A SIGHASH_SINGLE|SIGHASH_ANYONECANPAY signature (including the postfix type byte) which
       * spends the primary's part of the multisig contract's output.  This signature only covers
       * the primary's refund output and thus the secondary is free to do what they wish with their
       * part of the multisig output.
       * </pre>
       *
       * <code>required bytes signature = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        copyOnWrite();
        instance.clearSignature();
        return this;
      }

      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       * @return Whether the info field is set.
       */
      @java.lang.Override
      public boolean hasInfo() {
        return instance.hasInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       * @return The info.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getInfo() {
        return instance.getInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       * @param value The info to set.
       * @return This builder for chaining.
       */
      public Builder setInfo(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInfo(value);
        return this;
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol.
       * </pre>
       *
       * <code>optional bytes info = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearInfo() {
        copyOnWrite();
        instance.clearInfo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.UpdatePayment)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.UpdatePayment();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "clientChangeValue_",
              "signature_",
              "info_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0002\u0001\u1503\u0000\u0002" +
                "\u150a\u0001\u0003\u100a\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.UpdatePayment> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.UpdatePayment.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.UpdatePayment>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.UpdatePayment)
    private static final org.bitcoin.paymentchannel.Protos.UpdatePayment DEFAULT_INSTANCE;
    static {
      UpdatePayment defaultInstance = new UpdatePayment();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        UpdatePayment.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.UpdatePayment getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<UpdatePayment> PARSER;

    public static com.google.protobuf.Parser<UpdatePayment> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface PaymentAckOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.PaymentAck)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     * @return Whether the info field is set.
     */
    boolean hasInfo();
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     * @return The info.
     */
    com.google.protobuf.ByteString getInfo();
  }
  /**
   * <pre>
   * This message is sent as an acknowledgement of an UpdatePayment message
   * </pre>
   *
   * Protobuf type {@code paymentchannels.PaymentAck}
   */
  public  static final class PaymentAck extends
      com.google.protobuf.GeneratedMessageLite<
          PaymentAck, PaymentAck.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.PaymentAck)
      PaymentAckOrBuilder {
    private PaymentAck() {
      info_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int INFO_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString info_;
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     * @return Whether the info field is set.
     */
    @java.lang.Override
    public boolean hasInfo() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     * @return The info.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getInfo() {
      return info_;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     * @param value The info to set.
     */
    private void setInfo(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      info_ = value;
    }
    /**
     * <pre>
     * Information about this update. Used to extend this protocol
     * </pre>
     *
     * <code>optional bytes info = 1;</code>
     */
    private void clearInfo() {
      bitField0_ = (bitField0_ & ~0x00000001);
      info_ = getDefaultInstance().getInfo();
    }

    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.PaymentAck parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.PaymentAck prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * This message is sent as an acknowledgement of an UpdatePayment message
     * </pre>
     *
     * Protobuf type {@code paymentchannels.PaymentAck}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.PaymentAck, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.PaymentAck)
        org.bitcoin.paymentchannel.Protos.PaymentAckOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.PaymentAck.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       * @return Whether the info field is set.
       */
      @java.lang.Override
      public boolean hasInfo() {
        return instance.hasInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       * @return The info.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getInfo() {
        return instance.getInfo();
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       * @param value The info to set.
       * @return This builder for chaining.
       */
      public Builder setInfo(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setInfo(value);
        return this;
      }
      /**
       * <pre>
       * Information about this update. Used to extend this protocol
       * </pre>
       *
       * <code>optional bytes info = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInfo() {
        copyOnWrite();
        instance.clearInfo();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.PaymentAck)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.PaymentAck();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "info_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0001\u0001\u0001\u0000\u0000\u0000\u0001\u100a\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.PaymentAck> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.PaymentAck.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.PaymentAck>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.PaymentAck)
    private static final org.bitcoin.paymentchannel.Protos.PaymentAck DEFAULT_INSTANCE;
    static {
      PaymentAck defaultInstance = new PaymentAck();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        PaymentAck.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.PaymentAck getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<PaymentAck> PARSER;

    public static com.google.protobuf.Parser<PaymentAck> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface SettlementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Settlement)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     * @return Whether the tx field is set.
     */
    boolean hasTx();
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     * @return The tx.
     */
    com.google.protobuf.ByteString getTx();
  }
  /**
   * Protobuf type {@code paymentchannels.Settlement}
   */
  public  static final class Settlement extends
      com.google.protobuf.GeneratedMessageLite<
          Settlement, Settlement.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Settlement)
      SettlementOrBuilder {
    private Settlement() {
      tx_ = com.google.protobuf.ByteString.EMPTY;
    }
    private int bitField0_;
    public static final int TX_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString tx_;
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     * @return Whether the tx field is set.
     */
    @java.lang.Override
    public boolean hasTx() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     * @return The tx.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getTx() {
      return tx_;
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     * @param value The tx to set.
     */
    private void setTx(com.google.protobuf.ByteString value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000001;
      tx_ = value;
    }
    /**
     * <pre>
     * A copy of the fully signed final contract that settles the channel. The client can verify
     * the transaction is correct and then commit it to their wallet.
     * </pre>
     *
     * <code>required bytes tx = 3;</code>
     */
    private void clearTx() {
      bitField0_ = (bitField0_ & ~0x00000001);
      tx_ = getDefaultInstance().getTx();
    }

    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Settlement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.Settlement prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * Protobuf type {@code paymentchannels.Settlement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.Settlement, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Settlement)
        org.bitcoin.paymentchannel.Protos.SettlementOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.Settlement.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       * @return Whether the tx field is set.
       */
      @java.lang.Override
      public boolean hasTx() {
        return instance.hasTx();
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       * @return The tx.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getTx() {
        return instance.getTx();
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       * @param value The tx to set.
       * @return This builder for chaining.
       */
      public Builder setTx(com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setTx(value);
        return this;
      }
      /**
       * <pre>
       * A copy of the fully signed final contract that settles the channel. The client can verify
       * the transaction is correct and then commit it to their wallet.
       * </pre>
       *
       * <code>required bytes tx = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTx() {
        copyOnWrite();
        instance.clearTx();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Settlement)
    }
    private byte memoizedIsInitialized = 2;
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.Settlement();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "tx_",
            };
            java.lang.String info =
                "\u0001\u0001\u0000\u0001\u0003\u0003\u0001\u0000\u0000\u0001\u0003\u150a\u0000";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.Settlement> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.Settlement.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.Settlement>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return memoizedIsInitialized;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        memoizedIsInitialized = (byte) (arg0 == null ? 0 : 1);
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Settlement)
    private static final org.bitcoin.paymentchannel.Protos.Settlement DEFAULT_INSTANCE;
    static {
      Settlement defaultInstance = new Settlement();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Settlement.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.Settlement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Settlement> PARSER;

    public static com.google.protobuf.Parser<Settlement> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }

  public interface ErrorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:paymentchannels.Error)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     * @return Whether the code field is set.
     */
    boolean hasCode();
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     * @return The code.
     */
    org.bitcoin.paymentchannel.Protos.Error.ErrorCode getCode();

    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return Whether the explanation field is set.
     */
    boolean hasExplanation();
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return The explanation.
     */
    java.lang.String getExplanation();
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return The bytes for explanation.
     */
    com.google.protobuf.ByteString
        getExplanationBytes();

    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     * @return Whether the expectedValue field is set.
     */
    boolean hasExpectedValue();
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     * @return The expectedValue.
     */
    long getExpectedValue();
  }
  /**
   * <pre>
   * An Error can be sent by either party at any time
   * Both parties should make an effort to send either an ERROR or a CLOSE immediately before
   * closing the socket (unless they just received an ERROR or a CLOSE)
   * </pre>
   *
   * Protobuf type {@code paymentchannels.Error}
   */
  public  static final class Error extends
      com.google.protobuf.GeneratedMessageLite<
          Error, Error.Builder> implements
      // @@protoc_insertion_point(message_implements:paymentchannels.Error)
      ErrorOrBuilder {
    private Error() {
      code_ = 8;
      explanation_ = "";
    }
    /**
     * Protobuf enum {@code paymentchannels.Error.ErrorCode}
     */
    public enum ErrorCode
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <pre>
       * Protocol timeout occurred (one party hung).
       * </pre>
       *
       * <code>TIMEOUT = 1;</code>
       */
      TIMEOUT(1),
      /**
       * <pre>
       * Generic error indicating some message was not properly
       * </pre>
       *
       * <code>SYNTAX_ERROR = 2;</code>
       */
      SYNTAX_ERROR(2),
      /**
       * <pre>
       * formatted or was out of order.
       * </pre>
       *
       * <code>NO_ACCEPTABLE_VERSION = 3;</code>
       */
      NO_ACCEPTABLE_VERSION(3),
      /**
       * <pre>
       * A provided transaction was not in the proper structure
       * </pre>
       *
       * <code>BAD_TRANSACTION = 4;</code>
       */
      BAD_TRANSACTION(4),
      /**
       * <pre>
       * (wrong inputs/outputs, sequence, lock time, signature,
       * etc)
       * </pre>
       *
       * <code>TIME_WINDOW_UNACCEPTABLE = 5;</code>
       */
      TIME_WINDOW_UNACCEPTABLE(5),
      /**
       * <pre>
       * for the primary
       * </pre>
       *
       * <code>CHANNEL_VALUE_TOO_LARGE = 6;</code>
       */
      CHANNEL_VALUE_TOO_LARGE(6),
      /**
       * <pre>
       * too large for the primary
       * </pre>
       *
       * <code>MIN_PAYMENT_TOO_LARGE = 7;</code>
       */
      MIN_PAYMENT_TOO_LARGE(7),
      /**
       * <code>OTHER = 8;</code>
       */
      OTHER(8),
      ;

      /**
       * <pre>
       * Protocol timeout occurred (one party hung).
       * </pre>
       *
       * <code>TIMEOUT = 1;</code>
       */
      public static final int TIMEOUT_VALUE = 1;
      /**
       * <pre>
       * Generic error indicating some message was not properly
       * </pre>
       *
       * <code>SYNTAX_ERROR = 2;</code>
       */
      public static final int SYNTAX_ERROR_VALUE = 2;
      /**
       * <pre>
       * formatted or was out of order.
       * </pre>
       *
       * <code>NO_ACCEPTABLE_VERSION = 3;</code>
       */
      public static final int NO_ACCEPTABLE_VERSION_VALUE = 3;
      /**
       * <pre>
       * A provided transaction was not in the proper structure
       * </pre>
       *
       * <code>BAD_TRANSACTION = 4;</code>
       */
      public static final int BAD_TRANSACTION_VALUE = 4;
      /**
       * <pre>
       * (wrong inputs/outputs, sequence, lock time, signature,
       * etc)
       * </pre>
       *
       * <code>TIME_WINDOW_UNACCEPTABLE = 5;</code>
       */
      public static final int TIME_WINDOW_UNACCEPTABLE_VALUE = 5;
      /**
       * <pre>
       * for the primary
       * </pre>
       *
       * <code>CHANNEL_VALUE_TOO_LARGE = 6;</code>
       */
      public static final int CHANNEL_VALUE_TOO_LARGE_VALUE = 6;
      /**
       * <pre>
       * too large for the primary
       * </pre>
       *
       * <code>MIN_PAYMENT_TOO_LARGE = 7;</code>
       */
      public static final int MIN_PAYMENT_TOO_LARGE_VALUE = 7;
      /**
       * <code>OTHER = 8;</code>
       */
      public static final int OTHER_VALUE = 8;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static ErrorCode valueOf(int value) {
        return forNumber(value);
      }

      public static ErrorCode forNumber(int value) {
        switch (value) {
          case 1: return TIMEOUT;
          case 2: return SYNTAX_ERROR;
          case 3: return NO_ACCEPTABLE_VERSION;
          case 4: return BAD_TRANSACTION;
          case 5: return TIME_WINDOW_UNACCEPTABLE;
          case 6: return CHANNEL_VALUE_TOO_LARGE;
          case 7: return MIN_PAYMENT_TOO_LARGE;
          case 8: return OTHER;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<ErrorCode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          ErrorCode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<ErrorCode>() {
              @java.lang.Override
              public ErrorCode findValueByNumber(int number) {
                return ErrorCode.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return ErrorCodeVerifier.INSTANCE;
      }

      private static final class ErrorCodeVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new ErrorCodeVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return ErrorCode.forNumber(number) != null;
              }
            };

      private final int value;

      private ErrorCode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:paymentchannels.Error.ErrorCode)
    }

    private int bitField0_;
    public static final int CODE_FIELD_NUMBER = 1;
    private int code_;
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     * @return Whether the code field is set.
     */
    @java.lang.Override
    public boolean hasCode() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     * @return The code.
     */
    @java.lang.Override
    public org.bitcoin.paymentchannel.Protos.Error.ErrorCode getCode() {
      org.bitcoin.paymentchannel.Protos.Error.ErrorCode result = org.bitcoin.paymentchannel.Protos.Error.ErrorCode.forNumber(code_);
      return result == null ? org.bitcoin.paymentchannel.Protos.Error.ErrorCode.OTHER : result;
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     * @param value The code to set.
     */
    private void setCode(org.bitcoin.paymentchannel.Protos.Error.ErrorCode value) {
      code_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
     */
    private void clearCode() {
      bitField0_ = (bitField0_ & ~0x00000001);
      code_ = 8;
    }

    public static final int EXPLANATION_FIELD_NUMBER = 2;
    private java.lang.String explanation_;
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return Whether the explanation field is set.
     */
    @java.lang.Override
    public boolean hasExplanation() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return The explanation.
     */
    @java.lang.Override
    public java.lang.String getExplanation() {
      return explanation_;
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @return The bytes for explanation.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getExplanationBytes() {
      return com.google.protobuf.ByteString.copyFromUtf8(explanation_);
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @param value The explanation to set.
     */
    private void setExplanation(
        java.lang.String value) {
      java.lang.Class<?> valueClass = value.getClass();
  bitField0_ |= 0x00000002;
      explanation_ = value;
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     */
    private void clearExplanation() {
      bitField0_ = (bitField0_ & ~0x00000002);
      explanation_ = getDefaultInstance().getExplanation();
    }
    /**
     * <pre>
     * NOT SAFE FOR HTML WITHOUT ESCAPING
     * </pre>
     *
     * <code>optional string explanation = 2;</code>
     * @param value The bytes for explanation to set.
     */
    private void setExplanationBytes(
        com.google.protobuf.ByteString value) {
      explanation_ = value.toStringUtf8();
      bitField0_ |= 0x00000002;
    }

    public static final int EXPECTED_VALUE_FIELD_NUMBER = 3;
    private long expectedValue_;
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     * @return Whether the expectedValue field is set.
     */
    @java.lang.Override
    public boolean hasExpectedValue() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     * @return The expectedValue.
     */
    @java.lang.Override
    public long getExpectedValue() {
      return expectedValue_;
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     * @param value The expectedValue to set.
     */
    private void setExpectedValue(long value) {
      bitField0_ |= 0x00000004;
      expectedValue_ = value;
    }
    /**
     * <pre>
     * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
     * </pre>
     *
     * <code>optional uint64 expected_value = 3;</code>
     */
    private void clearExpectedValue() {
      bitField0_ = (bitField0_ & ~0x00000004);
      expectedValue_ = 0L;
    }

    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.bitcoin.paymentchannel.Protos.Error parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.bitcoin.paymentchannel.Protos.Error prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * An Error can be sent by either party at any time
     * Both parties should make an effort to send either an ERROR or a CLOSE immediately before
     * closing the socket (unless they just received an ERROR or a CLOSE)
     * </pre>
     *
     * Protobuf type {@code paymentchannels.Error}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.bitcoin.paymentchannel.Protos.Error, Builder> implements
        // @@protoc_insertion_point(builder_implements:paymentchannels.Error)
        org.bitcoin.paymentchannel.Protos.ErrorOrBuilder {
      // Construct using org.bitcoin.paymentchannel.Protos.Error.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       * @return Whether the code field is set.
       */
      @java.lang.Override
      public boolean hasCode() {
        return instance.hasCode();
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       * @return The code.
       */
      @java.lang.Override
      public org.bitcoin.paymentchannel.Protos.Error.ErrorCode getCode() {
        return instance.getCode();
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       * @param value The enum numeric value on the wire for code to set.
       * @return This builder for chaining.
       */
      public Builder setCode(org.bitcoin.paymentchannel.Protos.Error.ErrorCode value) {
        copyOnWrite();
        instance.setCode(value);
        return this;
      }
      /**
       * <code>optional .paymentchannels.Error.ErrorCode code = 1 [default = OTHER];</code>
       * @return This builder for chaining.
       */
      public Builder clearCode() {
        copyOnWrite();
        instance.clearCode();
        return this;
      }

      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @return Whether the explanation field is set.
       */
      @java.lang.Override
      public boolean hasExplanation() {
        return instance.hasExplanation();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @return The explanation.
       */
      @java.lang.Override
      public java.lang.String getExplanation() {
        return instance.getExplanation();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @return The bytes for explanation.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString
          getExplanationBytes() {
        return instance.getExplanationBytes();
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @param value The explanation to set.
       * @return This builder for chaining.
       */
      public Builder setExplanation(
          java.lang.String value) {
        copyOnWrite();
        instance.setExplanation(value);
        return this;
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearExplanation() {
        copyOnWrite();
        instance.clearExplanation();
        return this;
      }
      /**
       * <pre>
       * NOT SAFE FOR HTML WITHOUT ESCAPING
       * </pre>
       *
       * <code>optional string explanation = 2;</code>
       * @param value The bytes for explanation to set.
       * @return This builder for chaining.
       */
      public Builder setExplanationBytes(
          com.google.protobuf.ByteString value) {
        copyOnWrite();
        instance.setExplanationBytes(value);
        return this;
      }

      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       * @return Whether the expectedValue field is set.
       */
      @java.lang.Override
      public boolean hasExpectedValue() {
        return instance.hasExpectedValue();
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       * @return The expectedValue.
       */
      @java.lang.Override
      public long getExpectedValue() {
        return instance.getExpectedValue();
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       * @param value The expectedValue to set.
       * @return This builder for chaining.
       */
      public Builder setExpectedValue(long value) {
        copyOnWrite();
        instance.setExpectedValue(value);
        return this;
      }
      /**
       * <pre>
       * Can be set by the client when erroring to the server if a value was out of range. Can help with debugging.
       * </pre>
       *
       * <code>optional uint64 expected_value = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearExpectedValue() {
        copyOnWrite();
        instance.clearExpectedValue();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:paymentchannels.Error)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.bitcoin.paymentchannel.Protos.Error();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "code_",
              org.bitcoin.paymentchannel.Protos.Error.ErrorCode.internalGetVerifier(),
              "explanation_",
              "expectedValue_",
            };
            java.lang.String info =
                "\u0001\u0003\u0000\u0001\u0001\u0003\u0003\u0000\u0000\u0000\u0001\u100c\u0000\u0002" +
                "\u1008\u0001\u0003\u1003\u0002";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.bitcoin.paymentchannel.Protos.Error> parser = PARSER;
          if (parser == null) {
            synchronized (org.bitcoin.paymentchannel.Protos.Error.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.bitcoin.paymentchannel.Protos.Error>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:paymentchannels.Error)
    private static final org.bitcoin.paymentchannel.Protos.Error DEFAULT_INSTANCE;
    static {
      Error defaultInstance = new Error();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        Error.class, defaultInstance);
    }

    public static org.bitcoin.paymentchannel.Protos.Error getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<Error> PARSER;

    public static com.google.protobuf.Parser<Error> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
